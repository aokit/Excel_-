■Range_組織辞書　から　組織辞書┏　へ：

これまで：
組織辞書はシート上では長さ（１行の列数）の異なる、かつ、長さの変わりうる
行数の変わりうる行の連続した範囲であったため、事前に範囲を定めることが
難しいと考え『概ね最大列数』を２０と想定して　Range_組織辞書　を設定して
いた。概ねこれでよさそうではあった。

これから：
組織辞書の読み取りを　組織辞書読み取り　から　SingleHomeDict_namedRange
に一般化した。SingleHomeDict_namedRange　は、 SingleHomeDict　による
単一の見出し　から　複数の類義　を表現する　１対多対応　のシート上の範囲
を　辞書　に読み込むプロシジャである。
単一の見出し　もしくは　複数の類義　のいずれかがマッチすると、マッチする
行の行番号を返す　辞書　が得られる。
（単一の見出し　が得られるわけではないことに注意。）
（また、単一の見出し　と
　一致する文字列が、　複数の類義　の中に再登場することは許容されない。
　＜そのはず…そうなったらどういう動作をするのかは確認していないが、確認
　　しておいたほうがよいと思う＞　【要確認】）
（また、ある　単一の見出し　に属する　複数の類義　のうちの一つが、他の
　単一の見出し　に属する　複数の類義　に再登場することは許容されない。
　＜こちらも、そのはず…そうなったらどういう動作をするのかは確認していな
　　いが、確認しておいたほうがよいと思う＞　【要確認】
　なお、複数の類義　の要素について、同じ文字列の再登場　を許す　辞書　を
　得る別のプロシジャとして　MultiHomeDict　を別途作成してある。）

この　SingleHomeDict_namedRange　では、組織辞書の性質；
・１行の列数が不定
・行数が不定
＜ただし、行はかならず　第１の列　を有する。それにより行数を計数できる＞
＜また、最初の空行の前までが範囲となる＞
を、適切に処理できるようにした。つまり、範囲の左上角のセルを指定すればよ
いようにしたので、事前に想定列数や行数を設定する
・Range_組織辞書
の使用をやめ、組織辞書の左上角のセルに対する名前
・組織辞書┏
を使用することにした。
また、組織辞書の左上角のセルはいままで
・左上cell_組織辞書
と名付けていた。　組織辞書┏　と同義になるが、使っていないことから、この
名前は廃止した。

Range_組織辞書　は、　組織略称クリア　でも使われているため、
組織辞書┏　から　Range_組織辞書　を得る；
つまり、左上セル　を範囲として与えると、　不定列数連続業の範囲　返す関数
を定義しておくことが必要である。
Function Range_expand_ULA2VarColRows(Range_of_左上セルAs Range) As Range
を書いておこう。

また、名付けチェックについては、　Range_組織辞書　に代えて　組織辞書┏　を
設定しておく。

あわわ：

SingleHomeDict_namedRange
は、
MultiHomeDict_namedRange
の特殊例、であって、

SingleHomeDict_namedRange
は
SingleHomeDict
とは全く独立になっていたよ・・・

何ってこった。

SingleHomeDict
単体は、必要なのか？

SingleHomeDict
と
MultiHomeDict_namedRange
の特殊例である
SingleHomeDict_namedRange
は、きちんと一致するのか？

それは、一旦おいておいて、　MultiHomeDict_namedRange　から左上角(ULA)拡張
のコードを取ってこよう。
非常にシンプル；
   Dim R_n As Range
   Set R_n = ThisWorkbook.Names(strName).RefersToRange
   Set R_n = range_連続列最大行_range(R_n)
だったよ。　range_連続列最大行_range　が、まさにこれ。

Function range_連続列最大行_namedrange(strRangeName As String) as Range
   Dim R_n As Range
   Set R_n = ThisWorkbook.Names(strRangeName).RefersToRange
   ' Set R_n =...
   Set range_連続列最大行_namedrange = range_連続列最大行_range(R_n)
End Function
として、必要な箇所で以下のようにそのまま呼び出すか、
   Set ◆拡張範囲◆ = range_連続列最大行_namedrange(◆左上セルの名前◆）
必要なら以下で再呼び出しするのがいいかも。
Function Range_expand_ULA2VarColRows(左上セル As Range) As Range
   Range_expand_ULA2VarColRows = range_連続列最大行_namedrange(左上セル)
End Function
あるいは、
Function 左上セルから連続行拡張(左上セル As Range) As Range
   左上セルから連続行拡張 = range_連続列最大行_namedrange(左上セル)
End Function

.Clear したあと範囲を再度 Set するという間違いもあって、それも修正。

Range_組織辞書
は使われなくなった・・・と思ったのだけれど、範囲が変わったらその
新しい範囲でまた、Range_組織辞書　と名付けるなどという操作を、
▼１▼２▼３など随所ででやっている。

完全になくすまでまだちょっとかかりそう。

そのまえに、現在未定義で残っている名前を削除した。
削除した名前は次のとおり。

BU抽出
デバッグ
期間＿開始
期間＿終了
期間の審査数
区分抽出
仕向地抽出
包括抽出

これらは、半手作業であったときに使っていた名前で、現在すべて #REF! エラー
となっている。

以上
2021/02/11-1100_1424========================================================

特例抽出
非許可特例抽出

が残っていた。これらも削除
2021/02/12-0800_0825========================================================

別表１の自動記入までの対応をした。その際、連続列の最大行のバグをフィックスした
その関係で、むしろバグでハックしてあった　▼１　での組織辞書の構成がおそらく、
クリアするときの領域取得で抜け出せなくなっている。
これをバグフィクスしないと。

2021/02/13-0000_0000========================================================

■　関数の引数の取扱に対する誤解によるバグフィクス

行の最終列　や　列の最終行　などにおいて、何回目の　.End(xlToRight)　または
.End(xlDown)　で見つけた　（前が空白のセルなら）後が空白のセル／（後が空白の
セルなら）前が空白のセル　であるか、を、数えて終了するための引数として、 q を
Optional として与えているのだが、これが、副作用を受けている。
関数（プロシジャではなくて）の引数であるから、直感的には ByVal がデフォルトと
して設定されていると思うのだが、そうではなくて、 VBA では ByRef が『関数で
あっても』デフォルトらしい。つまり、関数の中で q の値を制御のために変更して
しまうと、それによって、関数が終了したあとの q にはその影響が副作用として残る
のだ。だから、関数を繰り返して呼ぶような場合、q の値は直前の呼び出しによって、
影響されてしまう。毎回 q を明示的に（直値で）設定すれば問題が生じないのは
当然なのだが、そうではなく、呼び出す側も変数で取り扱うと、影響が蓄積してしま
うという、非常に困った使用である。
そもそも、ByRef がデフォルトなら、直値など使えないようになっていればいいのに
それでは毎回変数を置かねばならないので不便だからなのか、引数に、当然のように
直値が使えるのに、引数に変数を指定したときは、ByRefとして振る舞ってしまう。
ほんとにやめてほしい。

...Optional q As Long = 0...
＜↓変更↓＞
...Optional ByVal q As Long = 0...

2021/02/14-0000_1025========================================================

▼０　の　列の最終行_range の引数の条件のバグ対応の応急措置を修正

   ' rz = 列の最終行_range(Cells(r0, c1), , 3) ' 最初の空白行の手前の行
   ' ┗・・・なぜかここ、パラメータ（上記の３）を増やさないといけなかった。
   ' 　　　　どうしてかは未解明
   '＜↓変更↓＞
   rz = 列の最終行_range(Cells(r0, c1),, 1) ' 最初の空白行の手前の行

   ' 表示のための名前付け範囲生成：
   ' その下の空白につづいて状況表示用のセルとその名前を配置する。
   ' r0 = 列の最終行_range(Cells(rz, c1), , 4)
   ' rz = 列の最終行_range(Cells(rz, c1), , 5)
   '＜↓変更↓＞
   r0 = 列の最終行_range(Cells(rz, c1),, 1)
   rz = 列の最終行_range(Cells(r0, c1),, 1) ' 最初の空白行の手前の行

▼１　の　
   Call PrintArrayOnNamedRange(strName, str組織辞書)
で、ループに入ってしまっているようだ。

右が空きセル　のとき　xlToRight
下が空きセル　のとき　xlDown
だと、直感的には　その場所から動かないでもらいたい　のだが
次の
左が空きセル　もしくは　表の論理最も右のセル
上が空きセル　もしくは　表の論理最も下のセル
に移動してしまうことが問題。
『右が空きセルなら xlToRight しない』などの関数を組み込めばいいかも。
↓訂正↓
いや、これだと、q を２以上にしても、次のブロックに行けなくなっちゃう。
問題は、１個だけのセルの島に居るときには、右の端であり左の端なので、
左の端に到着したつもりだったけれど、それが右の端でもあったので、
もう一度『行け』と言われたら出ていくようにしないと。
右へ行こうとしたときに、
右（column＋１）が空きセルなら、
　保留回数を確認して、保留回数が０回より大きければ
　　保留回数を０に戻して、そのうえで、右へ。
　保留回数が０回なら
　　保留回数を１にして、右へは行かない。
右（column＋１）が空きセルでなければ、
　保留回数（は０のはずだが）を０に戻して、その上で右へ。
・・・
これを入れれば、明らかに右端に居る、とわかっているときには、q=2 で
移動できる。

それを組み込んだ。そうしたら、こんどは　▼３、▼５、▼７などでバグ

承認記録　を読み込む際に、列の最終行などがうまく機能しない。
理由は、承認記録が、シートの全セルを範囲とする名前であるから。
つまり、それより下のセルもなければ、それより右のセルもない。
シートの最も右の最も下のセルと同じ条件。
それをきちんと取り扱うようにしてもいいかもしれないが、
ひとまず、
名前『承認記録』の示す範囲を、シートの全セルではなくて、シートの左上
の１セルのみの代表セルとした。
（承認記録は、ほぼすべてのセルが埋まっているのでもともとそれでも
　よかったと思われる）
これにてひとまず、解決。
   If (mc = c2) Or (mc = s.Columns.Count) Then
      Debug.Print("行の最終列_rangeに与えられた範囲がシートの最右列に達しています")
      行の最終列_range = mc
      Exit Function
   End If
なども入れておいた。

▼７には問題がまだあるみたい。

仕向地集計名配列生成　に問題がある。

？？問題あるのが、未割当別名に移った？？
PrintArrayOnNamedRange("未割当別名", ary未割当仕向, 1)

名前定義『未割当別名』のセルが移動（間違えて設定）されてしまっていたかも。
これがオブジェクト見つからないエラーっぽい。

未割当別名について、定義ができているかどうか、ではなくて、定義する
スクリプト（集計状況のところの）が走ってしまっているようにみえる。

