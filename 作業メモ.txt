＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
■　連続列の最大行　に代わる range_n_TabBottom_range(R, k, n) で
　　PrintArrayOnRange　を作成した
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

＿別表＿において、別表１２３への転記のうち、別表１に関して『別表１』と名付けた
範囲を引数として渡すことで、シート上の空セルではない連続領域を表とみなして指定
した配列からの転記を行うプロシジャを以下のように使っている。
・・・・・・・・
   ' Set R_1 = ThisWorkbook.Names("別表１").RefersToRange.Offset(1,0)
   ' ┗範囲全体を渡してもOK
   Set R_1 = ThisWorkbook.Names("別表１").RefersToRange.Offset(1,0).Resize(1)
   ' ┗範囲の最初の行を渡してもOK
   Call PrintArrayOnRange(VP, R_1, 0, 2)
・・・・・・・・
上記の PrintArrayOnRange がそのプロシジャである。その中で；
・・・・・・・・
Private Sub PrintArrayOnRange(ByRef Ary As Variant, _
                              R_n As Range, _
                              Optional nr As Long = 0, _
                              Optional nc As Long = 0, _
                              Optional BC As String ="*")
・・・・
・・・・
・・・・
   Set R_n = range_n_TabBottom_range(R_n)
   ' これはまだ、行の拡張のみ。列の拡張は対応していない。
・・・・・・・・
として使っているのが、指定した範囲の（指定した列について、その列に値のある）
最も下の行まで、拡張した範囲を返す関数　range_n_TabBottom_range　である。
・・・・・・・・
Function range_n_TabBottom_range(R_n As Range, _
                                 Optional k As Long = 1, _
                                 Optional n As Long = 1) As Range
・・・・・・・・
ブックにおけるシート上の範囲を R_n で指定して、その k 列目について、値の
あるセルが連続する行を探して、R_n を拡張した範囲を返す。
k のデフォルト値は 1 である。これは、 R_n の１列目を表す。R_n の列数より
大きい k を指定することもできる。その場合は、拡張の処理をその列のセルに
よって判断する。つまり R_n で指定した列より右側の列で判断することも可能で
あるが、返す範囲は、 R_n で指定した列（の対応する行数）である。
オプション変数で、回数 n を指定して、n 個目の範囲を得ることもできる。
この関数の中ではブックにおけるシート上の範囲 R_n の k 列目について、値の
あるセルが連続する行の範囲に拡張した範囲を返す関数として、
range_TabBottom_range を利用している。これは、
range_n_TabBottom_range の n=1 とした特別場合にあたる。
・・・・・・・・
Function range_TabBottom_range(R_n As Range, _
                               Optional k As Long = 1, _
                               Optional q As Long = 1) As Range
   '
   ' R_n で与えられた範囲の 第１行の k 列目（デフォルトは１列目）
   ' から下方向に値があるセルをたどって一番下のセルまで含むように
   ' R_n の列数はそのまま、行数だけ拡大して返す。
   ' ※ R_n で与えられた範囲の 第１行の k 列目の下がすでに 空セル
   '    だったら、拡大しない。
   '
   ' R_n が１行のみで、k 列の上のセルも下のセルも空セルの場合、
   ' （２行以上あれば、２回の実行で次の範囲に移動するのだが）
   ' １回の実行で次の範囲に移動してしまう。それを抑制するために
   ' 複数回の呼び出しは、回数を指定する別の関数によって記述して、
   ' この関数自体には、何回目の呼び出しであるかを伝えるようにする。
   ' そのために 引数 q を使う。デフォルト値は 1 である。
   ' 続けて実行するときには、連続何回目であるかを q で与える。
   ' （連続３回実行するときは、q が 3,2,1 と変化する）
・・・・・・・・
2021/02/20-1743
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
上記のqは不要なので実装からはずした。
▼９の中に、使わないコードが残されているので、あとで削除したいところ。
▼９
▼１０
を実装。
Range("＜範囲につけた名前＞")
というアクセス方法は使わないことにする（コードの記述がシートに属さないと
オブジェクトが見つからなくなるので）
ThisWorkbook.Names("＜範囲につけた名前＞").RefersToRange
で Range を手に入れて、 OffsetやCellsやResizeなどを使ってアクセス範囲を変え、
また、値の書き換えなどを行うことにする。
・・・・・・・・
2021/02/20-1743
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
・・・・・・・・
▼７で仕向地集計を行う際に、未割当の仕向地名を　未割当別名　という名付け範囲に
印字するのだが、未割当となった管理番号も列記するようにした。
2021/02/23-1301
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
